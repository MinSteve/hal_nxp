/*!
@defgroup i2s_pal I2S - Peripheral Abstraction Layer (I2S PAL) 
@brief The S32 SDK provides a Peripheral Abstraction Layer for I2S
modules of S32 SDK devices.
<p>
  The I2S PAL is designed to be portable across all 
  platforms and IPs which support I2S communication.
</p>
  ## Integration guideline ##
 
  ### Compilation units ###

  The following files need to be compiled in the project:
  \verbatim
  ${S32SDK_PATH}\platform\pal\src\i2s\i2s_pal.c
  \endverbatim

  ### Include path ###

  The following paths need to be added to the include path of the toolchain:
  \verbatim
  ${S32SDK_PATH}\platform\pal\inc
  i2s_pal_cfg.h path (this file is provided by user or generated by pex)
  \endverbatim

  ### Compile symbols ###

  No special symbols are required for this component

  ### Dependencies ###

  \ref sai
  \ref flexio_i2s
  \ref edma
  \ref osif 
  \ref clock manager
  \ref interrupt_manager
  
  ## How to integrate I2S PAL in your application ##
<p>
  Unlike the other drivers, I2S PAL modules need to include a configuration
  file named i2s_pal_cfg.h, which allows the user to specify which IPSs are used
  and how many resources are allocated for each of them (state structures).
  The following code example shows how to configure one instance for each
  available I2S IPs.

 @code
 #ifndef i2s_pal_cfg_H
 #define i2s_pal_cfg_H

 /* Define which IP instance will be used in current project */
 #define I2S_OVER_FLEXIO
 #define I2S_OVER_SAI

 /* Define the resources necessary for current project */
 #define NO_OF_FLEXIO_MASTER_INSTS_FOR_I2S 1U
 #define NO_OF_FLEXIO_SLAVE_INSTS_FOR_I2S 1U
 #define NO_OF_SAI_INSTS_FOR_I2S  1U

 #endif /* i2s_pal_cfg_H */
 @endcode
 
 The following table contains the matching between platforms and available IPs
 IP/MCU     |S32K116|S32K118|S32K142|S32K144|S32K146|S32K148|MPC5748G|MPC5746C|
 -----------|-------|:-----:|-------|-------|-------|-------|--------|--------|
 SAI        |  NO   |  NO   |  NO   |  NO   |  NO   |  YES  |   YES  |   YES  |
 FLEXIO_I2S |  YES  |  YES  |  YES  |  YES  |  YES  |  YES  |   NO   |   NO   |
</p>
<p>
  In order to use the I2S driver it must be first initialized 
  using function I2S_Init. Once initialized, it cannot 
  be initialized again for the same instance until it is de-initialized, using 
  I2S_Deinit. Different instances can work independently 
  of each other.
</p>

  ## Important Notes ##
<p>
  - I2S PAL only works in half duplex mode, meaning it cannot send and receive simultaneously over one instance.
  - The driver enables the interrupts for the corresponding module, but any interrupt priority 
  setting must be done by the application.
  - When using SAI module for I2S, a success status of sending operation means that all data has been pushed to hardware fifo (not output pin),
  up to 8 tx words will be discarded if users call deinit or switch to receiving operation right after that.
</p>
 ## Example code ##
 @code
 
  /* Buffers */
  
 uint8_t tx[6] = {1,2,3,4,5,6};

 /* Callback to continue sending data */
void i2s_Callback0(i2s_event_t event, void *userData) 
{
    /* Get from userData the I2S instance of the I2S module */
    i2s_instance_t* instance;
    instance = (i2s_instance_t*)(userData);

    /* Check the event type:
     *  - set TX buffers on I2S_EVENT_TX_EMPTY
     */
    if (event == I2S_EVENT_TX_EMPTY)
    {
        I2S_SetTxBuffer(instance, tx, 6UL);
    }
}
 /* Define I2S instance */
i2s_instance_t flexioInst = {I2S_INST_TYPE_FLEXIO,0UL};
 /* Configure I2S */
i2s_user_config_t i2sUserConfig0 =
{
    .baudRate      = 100000U,
    .mode          = I2S_MASTER,
    .wordWidth     = 8U,
    .transferType  = I2S_USING_INTERRUPT,
    .rxDMAChannel  = 0U,
    .txDMAChannel  = 0U,
    .callback      = i2s_Callback0,
    .callbackParam = &flexioInst,
    .extension     = NULL 
};

 /* Configure FLEXIO pins routing */
 extension_flexio_for_i2s_t extension;
 extension.txPin = 0U;
 extension.rxPin = 1U;
 extension.sckPin = 2U;
 extension.wsPin = 3U;
 i2sUserConfig0.extension = &extension;
 
 /* Initializes i2s master for flexio 0 and send 6 words */
 I2S_Init(&flexioInst, &i2sUserConfig0);
 I2S_SendData(&flexioInst, tx, 6UL);
 /* Wait for sending complete */
 while (I2S_GetStatus(&flexioInst, NULL) == STATUS_BUSY);
 I2S_Deinit(&flexioInst);
 
 @endcode
@}*/